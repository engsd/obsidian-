# 全自动知识库构建器 - Python学习版教学导读

## 什么是这个工具？

这个工具是一个Python脚本，可以帮助你自动创建Obsidian知识库。但更重要的是，它是一个绝佳的Python学习案例！通过这个脚本，你可以学到很多Python的基础知识和实用技巧。

## 这个工具能做什么？

1. **自动创建文件夹结构**：根据你的大纲自动创建主题和子主题文件夹
2. **生成原子笔记**：为每个知识点创建单独的笔记文件
3. **提取钩子内容**：将钩子（问题或思考点）自动添加到对应的笔记中
4. **创建MOC笔记**：为每个子主题创建一个概览笔记（MOC - Map of Content）
5. **建立链接网络**：自动创建笔记之间的链接关系
6. **提取核心概念**：将二级标题下的斜体内容(*...*)提取到MOC笔记中

## Python基础知识解析

### 1. 方法和属性

在Python中，**方法**是对象可以执行的操作，而**属性**是对象的特征或数据。让我们看看代码中的例子：

```python
# 文件操作中的方法
os.path.exists(markdown_file)  # exists()是一个方法，检查文件是否存在
os.path.join(base_path, h2_folder)  # join()是一个方法，连接路径
os.makedirs(h2_path, exist_ok=True)  # makedirs()是一个方法，创建目录

# 字符串的方法
line.startswith('## ')  # startswith()是一个方法，检查字符串是否以## 开头
line.strip()  # strip()是一个方法，去除字符串两端的空白
line[3:].strip()  # [3:]是切片操作，获取从第3个字符开始到末尾的子字符串

# 列表的方法
structure[current_h2][current_h3].append(item)  # append()是一个方法，向列表添加元素
md_files = [f for f in os.listdir(current_dir) if f.endswith('.md')]  # endswith()是一个方法
```

**属性**的例子：

```python
sys.argv  # argv是sys模块的一个属性，包含命令行参数
stats['folders']  # 'folders'是字典stats的一个键，可以看作是属性
```

### 2. if嵌套

**if嵌套**是指在一个if语句内部再使用另一个if语句。这在需要检查多个条件时非常有用。让我们看看代码中的例子：

```python
# 这是一个复杂的if嵌套例子
for line in lines:
    line = line.strip()
    if not line:  # 第一层if：检查行是否为空
        continue
        
    if line.startswith('## '):  # 第二层if：检查是否以## 开头
        # 处理二级标题
        current_h2 = clean_filename(line[3:].strip())
        structure[current_h2] = {}
        italic_content_map[current_h2] = []
        stats['folders'] += 1
        
    elif line.startswith('### ') and current_h2:  # 第三层if：检查是否以### 开头且current_h2存在
        # 处理三级标题
        current_h3 = clean_filename(line[4:].strip())
        structure[current_h2][current_h3] = []
        stats['subfolders'] += 1
        
    elif line.startswith('- ') and current_h2 and current_h3:  # 第四层if：检查是否以- 开头且current_h2和current_h3都存在
        # 处理列表项
        item = line[2:].strip()
        
        if item.startswith('钩子:'):  # 第五层if：检查是否以钩子:开头
            # 处理钩子内容
            hook_content = item[3:].strip()
            
            if structure[current_h2][current_h3]:  # 第六层if：检查列表是否不为空
                last_note = structure[current_h2][current_h3][-1]
                if last_note not in hooks_map:  # 第七层if：检查笔记是否在钩子映射中
                    hooks_map[last_note] = []
                hooks_map[last_note].append(hook_content)
                stats['hooks'] += 1
        else:
            # 处理普通笔记标题
            structure[current_h2][current_h3].append(item)
            stats['atomic_notes'] += 1
    elif current_h2 and not current_h3 and ('*' in line):  # 另一个第三层if
        # 提取二级标题下的斜体内容
        italic_pattern = r'\*([^*]+)\*'
        italic_matches = re.findall(italic_pattern, line)
        for match in italic_matches:
            italic_content_map[current_h2].append(match.strip())
```

**if嵌套的工作原理**：
1. 程序从最外层的if开始检查条件
2. 如果条件为真，则执行该if块内的代码
3. 在该代码块内，可以继续使用其他if语句进行更细致的条件检查
4. 这种嵌套可以有多层，但通常建议不要嵌套太深，以免代码难以理解

### 3. 循环结构

代码中使用了多种循环结构，让我们看看：

```python
# for循环：遍历列表
for line in lines:
    # 处理每一行

# for循环：遍历字典
for h2_folder, subfolders in structure.items():
    # 处理每个二级标题及其子文件夹

# for循环：遍历另一个字典
for h3_subfolder, notes in subfolders.items():
    # 处理每个三级标题及其笔记

# for循环：遍历列表
for note in notes:
    # 处理每个笔记

# for循环：遍历斜体内容
for italic in italic_content_map[h2_folder]:
    # 处理每个斜体内容
```

### 4. 函数定义和调用

```python
# 函数定义
def build_complete_knowledge_base(markdown_file=None, base_path=None):
    """
    全自动构建完整知识库（修正版）
    """
    # 函数体
    
# 函数调用
build_complete_knowledge_base()
build_complete_knowledge_base(sys.argv[1])
build_complete_knowledge_base(sys.argv[1], sys.argv[2])
```

**函数要点**：
- 使用`def`关键字定义函数
- 函数可以有参数，如`markdown_file=None`（默认参数）
- 函数可以有返回值（这个函数没有显式返回值）
- 函数可以多次调用，每次可以传入不同的参数

### 5. 字典和列表操作

```python
# 字典操作
structure = {}  # 创建空字典
structure[current_h2] = {}  # 添加键值对
structure[current_h2][current_h3] = []  # 嵌套字典操作
hooks_map[last_note] = []  # 添加键值对
hooks_map[last_note].append(hook_content)  # 通过键获取值并操作

# 列表操作
stats['folders'] += 1  # 修改列表中的值
structure[current_h2][current_h3].append(item)  # 向列表添加元素
if structure[current_h2][current_h3]:  # 检查列表是否为空
    last_note = structure[current_h2][current_h3][-1]  # 获取列表最后一个元素
```

### 6. 文件操作

```python
# 读取文件
try:
    with open(markdown_file, 'r', encoding='utf-8') as f:
        content = f.read()
except UnicodeDecodeError:
    with open(markdown_file, 'r', encoding='gbk') as f:
        content = f.read()

# 写入文件
with open(moc_path, 'w', encoding='utf-8') as f:
    f.write(f"# {h3_subfolder}\n\n")
    f.write(f"主题：{h2_folder} > {h3_subfolder}\n\n")
    # 更多写入操作...
```

**文件操作要点**：
- 使用`with open()`语句可以自动处理文件的打开和关闭
- 需要指定文件模式（'r'读取，'w'写入）
- 可以指定编码（如'utf-8'）
- 使用try-except处理可能的异常（如编码错误）

### 7. 正则表达式

```python
# 提取斜体内容
italic_pattern = r'\*([^*]+)\*'  # 定义正则表达式模式
italic_matches = re.findall(italic_pattern, line)  # 查找所有匹配
for match in italic_matches:
    italic_content_map[current_h2].append(match.strip())  # 处理每个匹配
```

**正则表达式要点**：
- `\*([^*]+)\*` 匹配两个星号之间的内容
- `\*` 匹配星号字符
- `([^*]+)` 匹配一个或多个非星号字符，并捕获
- `re.findall()` 找到所有匹配的子字符串

### 8. 模块导入

```python
import os  # 导入os模块，用于操作系统相关功能
import re  # 导入re模块，用于正则表达式
import sys  # 导入sys模块，用于系统相关功能
from datetime import datetime  # 从datetime模块导入datetime类
```

**模块导入要点**：
- 使用`import`关键字导入模块
- 可以使用`from module import name`导入特定函数或类
- 导入后可以使用`module.name`的方式使用模块中的功能

## 如何使用这个工具？

### 第一步：准备你的大纲文件

创建一个Markdown文件（.md），按照以下格式编写你的学习大纲：

```markdown
## 主题一           → 这会创建一个顶级文件夹
*核心概念1*        → 斜体内容会写入MOC笔记的核心概念部分
*核心概念2*        → 可以添加多个核心概念
### 子主题1        → 这会创建一个子文件夹
- 文章标题1        → 这会创建一个原子笔记
- 钩子: 问题1      → 这会添加思考钩子到文章1
- 钩子: 问题2      → 可以添加更多钩子
- 文章标题2        → 这会创建另一个原子笔记
- 钩子: 问题3      → 这会添加钩子到文章2
```

### 第二步：运行工具

有三种方式可以运行这个工具：

1. **最简单的方式**（自动检测）：
   ```
   python 全自动知识库构建器_修正版.py
   ```
   这会自动在当前目录下查找Markdown文件并处理它。

2. **指定大纲文件**：
   ```
   python 全自动知识库构建器_修正版.py 我的大纲.md
   ```

3. **指定文件和输出目录**：
   ```
   python 全自动知识库构建器_修正版.py 我的大纲.md ./输出目录
   ```

### 第三步：查看结果

工具运行后，会创建以下结构：

```
输出目录/
├── 主题一/
│   ├── 子主题1/
│   │   ├── 子主题1 MOC.md          → 子主题的概览笔记
│   │   ├── 文章标题1.md             → 原子笔记1
│   │   └── 文章标题2.md             → 原子笔记2
├── 大纲学习总览.md                  → 整个知识库的总览
└── 全自动知识库构建器_修正版.py     → 工具本身
```

## Python进阶技巧

### 1. 函数式编程技巧

代码中使用了一些函数式编程的技巧，如列表推导式：

```python
# 列表推导式
md_files = [f for f in os.listdir(current_dir) 
           if f.endswith('.md') 
           and not f.startswith(('通用', '全自动', 'create', '总览'))]
```

这相当于：

```python
md_files = []
for f in os.listdir(current_dir):
    if f.endswith('.md') and not f.startswith(('通用', '全自动', 'create', '总览')):
        md_files.append(f)
```

**列表推导式的优势**：
- 代码更简洁
- 执行效率通常更高
- 表达力更强

### 2. 字符串格式化

代码中使用了多种字符串格式化方法：

```python
# f-string格式化（Python 3.6+）
f.write(f"# {h3_subfolder}\n\n")
f.write(f"主题：{h2_folder} > {h3_subfolder}\n\n")

# %格式化（旧式）
print("❌ 错误：找不到文件 %s" % markdown_file)

# format方法
print("顶级文件夹: {}个".format(stats['folders']))
```

**f-string的优势**：
- 语法简洁，易读
- 性能最好
- 可以直接嵌入表达式

### 3. 异常处理

代码中使用了try-except处理可能的异常：

```python
try:
    with open(markdown_file, 'r', encoding='utf-8') as f:
        content = f.read()
except UnicodeDecodeError:
    with open(markdown_file, 'r', encoding='gbk') as f:
        content = f.read()
```

**异常处理的要点**：
- 使用try-except捕获可能的异常
- 可以指定特定的异常类型（如UnicodeDecodeError）
- 可以在except块中提供替代方案

### 4. 条件表达式

代码中使用了多种条件表达式：

```python
# 简单条件
if not line:
    continue
    
# 复合条件
if line.startswith('### ') and current_h2:
    # 处理三级标题
    
# 多条件判断
if len(sys.argv) == 1:
    build_complete_knowledge_base()
elif len(sys.argv) == 2:
    if sys.argv[1] in ['-h', '--help', 'help']:
        print_usage()
    else:
        build_complete_knowledge_base(sys.argv[1])
elif len(sys.argv) == 3:
    build_complete_knowledge_base(sys.argv[1], sys.argv[2])
else:
    print_usage()
```

### 5. 嵌套数据结构

代码中使用了复杂的嵌套数据结构：

```python
# 嵌套字典
structure = {}
structure[current_h2] = {}
structure[current_h2][current_h3] = []

# 访问嵌套数据
for h2_folder, subfolders in structure.items():
    for h3_subfolder, notes in subfolders.items():
        for note in notes:
            # 处理每个笔记
```

**嵌套数据结构的要点**：
- 字典可以嵌套字典，形成多层级结构
- 访问嵌套数据需要逐层访问
- 使用多层循环可以遍历嵌套数据结构

### 6. 文件路径处理

代码中使用了os.path模块处理文件路径：

```python
# 连接路径
h2_path = os.path.join(base_path, h2_folder)
h3_path = os.path.join(h2_path, h3_subfolder)
note_path = os.path.join(h3_path, note_name)

# 获取文件名和扩展名
base_filename = os.path.splitext(os.path.basename(markdown_file))[0]

# 检查路径是否存在
if not os.path.exists(markdown_file):
    print(f"❌ 错误：找不到文件 {markdown_file}")
    return
```

**文件路径处理的要点**：
- 使用os.path.join()可以跨平台地连接路径
- 使用os.path.splitext()分割文件名和扩展名
- 使用os.path.exists()检查路径是否存在

### 7. 正则表达式高级用法

代码中使用了正则表达式提取特定内容：

```python
# 提取斜体内容
italic_pattern = r'\*([^*]+)\*'
italic_matches = re.findall(italic_pattern, line)
for match in italic_matches:
    italic_content_map[current_h2].append(match.strip())
```

**正则表达式的要点**：
- `r'\*([^*]+)\*'` 是一个原始字符串，表示匹配两个星号之间的内容
- `\*` 匹配星号字符
- `([^*]+)` 是一个捕获组，匹配一个或多个非星号字符
- `re.findall()` 找到所有匹配的子字符串，返回列表

### 8. 命令行参数处理

代码中使用了sys.argv处理命令行参数：

```python
if __name__ == "__main__":
    import sys
    
    if len(sys.argv) == 1:
        build_complete_knowledge_base()
    elif len(sys.argv) == 2:
        if sys.argv[1] in ['-h', '--help', 'help']:
            print_usage()
        else:
            build_complete_knowledge_base(sys.argv[1])
    elif len(sys.argv) == 3:
        build_complete_knowledge_base(sys.argv[1], sys.argv[2])
    else:
        print_usage()
```

**命令行参数处理的要点**：
- sys.argv是一个列表，包含命令行参数
- sys.argv[0]是脚本名称
- sys.argv[1]是第一个参数，以此类推
- 使用if-elif-else结构处理不同的参数组合
- 使用`if __name__ == "__main__":`确保代码只在直接运行时执行

### 第二步：运行工具

有三种方式可以运行这个工具：

1. **最简单的方式**（自动检测）：
   ```
   python 全自动知识库构建器_修正版.py
   ```
   这会自动在当前目录下查找Markdown文件并处理它。

2. **指定大纲文件**：
   ```
   python 全自动知识库构建器_修正版.py 我的大纲.md
   ```

3. **指定文件和输出目录**：
   ```
   python 全自动知识库构建器_修正版.py 我的大纲.md ./输出目录
   ```

### 第三步：查看结果

工具运行后，会创建以下结构：

```
输出目录/
├── 主题一/
│   ├── 子主题1/
│   │   ├── 子主题1 MOC.md          → 子主题的概览笔记
│   │   ├── 文章标题1.md             → 原子笔记1
│   │   └── 文章标题2.md             → 原子笔记2
├── 大纲学习总览.md                  → 整个知识库的总览
└── 全自动知识库构建器_修正版.py     → 工具本身
```

## 如何复刻这个文件？

如果你想在自己的项目中使用这个工具，只需要按照以下步骤操作：

### 方法一：直接复制

1. 找到 `全自动知识库构建器_修正版.py` 文件
2. 将它复制到你的项目文件夹中
3. 按照上面的使用说明运行它

### 方法二：创建新文件并复制代码

1. 在你的项目文件夹中创建一个新文件，命名为 `全自动知识库构建器_修正版.py`
2. 复制下面的完整代码到这个文件中
3. 保存文件
4. 按照上面的使用说明运行它

## Python学习建议

### 1. 从基础开始

如果你是Python新手，建议先掌握以下基础知识：

1. **变量和数据类型**：整数、浮点数、字符串、布尔值
2. **数据结构**：列表、元组、字典、集合
3. **控制流**：if语句、for循环、while循环
4. **函数**：定义函数、参数传递、返回值
5. **模块和包**：导入模块、创建模块、使用第三方包

### 2. 实践项目

学习编程最好的方式是通过实践项目。这个知识库构建器就是一个很好的实践项目，你可以：

1. **修改功能**：尝试添加新功能，如支持更多Markdown语法
2. **优化代码**：重构代码，使其更简洁高效
3. **添加错误处理**：增强程序的健壮性
4. **创建GUI**：使用tkinter或PyQt创建图形界面

### 3. 学习资源推荐

1. **官方文档**：[Python官方文档](https://docs.python.org/3/)
2. **在线教程**：
   - [廖雪峰的Python教程](https://www.liaoxuefeng.com/wiki/1016959663602400)
   - [菜鸟教程](https://www.runoob.com/python3/python3-tutorial.html)
3. **书籍**：
   - 《Python编程：从入门到实践》
   - 《流畅的Python》
   - 《Python Cookbook》
4. **视频课程**：
   - [Coursera上的Python课程](https://www.coursera.org/courses?query=python)
   - [Udemy上的Python课程](https://www.udemy.com/courses/search/?q=python)

### 4. 编程习惯

1. **代码风格**：遵循PEP 8规范，保持代码整洁一致
2. **注释**：为复杂的代码添加注释，解释其功能
3. **版本控制**：使用Git管理代码版本
4. **测试**：编写测试用例，确保代码正确性
5. **文档**：为你的代码编写文档，方便他人使用

### 5. 进阶学习路径

1. **面向对象编程**：学习类和对象、继承、多态
2. **函数式编程**：学习lambda函数、高阶函数、装饰器
3. **并发编程**：学习线程、进程、异步IO
4. **网络编程**：学习Socket、HTTP协议、Web框架
5. **数据分析**：学习NumPy、Pandas、Matplotlib
6. **机器学习**：学习Scikit-learn、TensorFlow、PyTorch

通过这个知识库构建器的学习，你已经接触到了Python的很多核心概念和技巧。继续深入学习，你会发现Python的强大功能和广泛应用！

### 完整代码

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
全自动知识库构建器 - 修正版

功能：一键完成从Markdown大纲到完整Obsidian知识库的构建
包括：
1. 解析Markdown大纲结构
2. 创建文件夹和原子笔记
3. 提取钩子内容并写入对应笔记
4. 建立链接网络：
   - 原子笔记 → MOC笔记
   - MOC笔记 → 学习总览
   - 原子笔记 → 学习总览（无链接）

使用方法：
python 全自动知识库构建器_修正版.py [大纲文件.md] [输出目录]
"""

import os
import re
import sys
from datetime import datetime

def build_complete_knowledge_base(markdown_file=None, base_path=None):
    """
    全自动构建完整知识库（修正版）
    """
    
    # 如果没有提供文件，自动检测当前目录
    if markdown_file is None:
        current_dir = os.getcwd()
        md_files = [f for f in os.listdir(current_dir) 
                   if f.endswith('.md') 
                   and not f.startswith(('通用', '全自动', 'create', '总览'))]
        if not md_files:
            print("❌ 错误：当前目录下没有找到合适的.md文件")
            return
        markdown_file = os.path.join(current_dir, md_files[0])
        print(f"📂 自动检测文件: {os.path.basename(markdown_file)}")
    
    # 确保文件存在
    if not os.path.exists(markdown_file):
        print(f"❌ 错误：找不到文件 {markdown_file}")
        return
    
    # 设置基础路径
    if base_path is None:
        base_path = os.path.dirname(markdown_file)
    
    # 获取基础文件名（不再用于创建大文件夹）
    base_filename = os.path.splitext(os.path.basename(markdown_file))[0]
    
    print(f"开始构建知识库: {base_filename}")
    print(f"输出路径: {base_path}")
    
    # 读取Markdown文件
    try:
        with open(markdown_file, 'r', encoding='utf-8') as f:
            content = f.read()
    except UnicodeDecodeError:
        with open(markdown_file, 'r', encoding='gbk') as f:
            content = f.read()
    
    # 清理函数
    def clean_filename(name):
        illegal_chars = r'[\/*?"<>|]'
        cleaned = re.sub(illegal_chars, '', name).strip()
        cleaned = re.sub(r'\s+', ' ', cleaned)
        return cleaned
    
    # 解析结构并收集钩子
    lines = content.strip().split('\n')
    structure = {}
    current_h2 = None
    current_h3 = None
    hooks_map = {}  # 存储每个笔记的钩子
    italic_content_map = {}  # 存储每个二级标题下的斜体内容
    
    # 统计信息
    stats = {
        'folders': 0,
        'subfolders': 0,
        'atomic_notes': 0,
        'hooks': 0,
        'moc_notes': 0
    }
    
    # 解析大纲结构
    for line in lines:
        line = line.strip()
        if not line:
            continue
            
        if line.startswith('## '):
            # H2 - 顶级文件夹
            current_h2 = clean_filename(line[3:].strip())
            structure[current_h2] = {}
            italic_content_map[current_h2] = []  # 初始化斜体内容列表
            stats['folders'] += 1
            
        elif line.startswith('### ') and current_h2:
            # H3 - 子文件夹
            current_h3 = clean_filename(line[4:].strip())
            structure[current_h2][current_h3] = []
            stats['subfolders'] += 1
            
        elif line.startswith('- ') and current_h2 and current_h3:
            # 原子笔记或钩子
            item = line[2:].strip()
            
            if item.startswith('钩子:'):
                # 这是钩子内容
                hook_content = item[3:].strip()
                
                # 找到最近的原子笔记标题
                if structure[current_h2][current_h3]:
                    last_note = structure[current_h2][current_h3][-1]
                    if last_note not in hooks_map:
                        hooks_map[last_note] = []
                    hooks_map[last_note].append(hook_content)
                    stats['hooks'] += 1
            else:
                # 这是原子笔记标题
                structure[current_h2][current_h3].append(item)
                stats['atomic_notes'] += 1
        elif current_h2 and not current_h3 and ('*' in line):
            # 提取二级标题下的斜体内容
            italic_pattern = r'\*([^*]+)\*'
            italic_matches = re.findall(italic_pattern, line)
            for match in italic_matches:
                italic_content_map[current_h2].append(match.strip())
    
    # 创建文件夹和文件 - 使用base_path作为根目录
    moc_links = {}  # 存储MOC笔记路径用于总览
    
    for h2_folder, subfolders in structure.items():
        h2_path = os.path.join(base_path, h2_folder)
        os.makedirs(h2_path, exist_ok=True)
        
        for h3_subfolder, notes in subfolders.items():
            h3_path = os.path.join(h2_path, h3_subfolder)
            os.makedirs(h3_path, exist_ok=True)
            
            # 创建MOC笔记
            moc_name = f"{h3_subfolder} MOC.md"
            moc_path = os.path.join(h3_path, moc_name)
            
            with open(moc_path, 'w', encoding='utf-8') as f:
                f.write(f"# {h3_subfolder}\n\n")
                f.write(f"主题：{h2_folder} > {h3_subfolder}\n\n")
                
                # 添加二级标题下的斜体内容
                if h2_folder in italic_content_map and italic_content_map[h2_folder]:
                    f.write("## 核心概念\n\n")
                    for italic in italic_content_map[h2_folder]:
                        f.write(f"- {italic}\n")
                    f.write("\n")
                
                f.write("## 相关文章\n\n")
                for note in notes:
                    f.write(f"- [[{note}]]\n")
                    
                f.write("\n## 链接\n\n")
                f.write(f"- [[{base_filename}学习总览]]\n")
                
            stats['moc_notes'] += 1
            
            if h2_folder not in moc_links:
                moc_links[h2_folder] = []
            moc_links[h2_folder].append(f"{h3_subfolder} MOC")
            
            # 创建原子笔记
            for note in notes:
                note_name = clean_filename(note) + '.md'
                note_path = os.path.join(h3_path, note_name)
                
                with open(note_path, 'w', encoding='utf-8') as f:
                    #f.write(f"# {note}\n\n")
                    
                    # 写入钩子内容
                    if note in hooks_map and hooks_map[note]:
                        for hook in hooks_map[note]:
                            f.write(f"#### {hook}\n\n")
                            f.write("\n")
                        
                    f.write("## 摘要\n\n")
                    f.write("\n")
                    f.write("## 要点\n\n")
                    f.write("- \n")
                    f.write("- \n")
                    f.write("- \n")
                    f.write("\n## 链接\n\n")
                    f.write(f"- [[{h3_subfolder} MOC]]\n")
                    # 原子笔记中不包含到学习总览的链接
    
    # 创建总览笔记
    overview_path = os.path.join(base_path, f"{base_filename}学习总览.md")
    
    with open(overview_path, 'w', encoding='utf-8') as f:
        f.write(f"# {base_filename}学习总览\n\n")
        f.write(f"系统性学习{base_filename}的知识中心\n\n")
        
        f.write("## 统计\n\n")
        f.write(f"- 顶级模块: {stats['folders']}个\n")
        f.write(f"- 子主题: {stats['subfolders']}个\n")
        f.write(f"- 原子笔记: {stats['atomic_notes']}篇\n")
        f.write(f"- 钩子: {stats['hooks']}个\n\n")
        
        f.write("## 模块导航\n\n")
        
        for h2_folder, mocs in sorted(moc_links.items()):
            f.write(f"### {h2_folder}\n\n")
            for moc in sorted(mocs):
                f.write(f"- [[{moc}]]\n")
            f.write("\n")
        
        # 更新说明
        f.write("---\n\n")
        f.write("> 💡 **链接结构说明**：\n")
        f.write("> - 原子笔记 → MOC笔记（单向链接）\n")
        f.write("> - MOC笔记 → 学习总览（单向链接）\n")
        f.write("> - 原子笔记 → 学习总览（无链接）\n")
    
    # 打印最终统计
    print(f"\n" + "="*50)
    print(f"知识库构建完成")
    print(f"顶级文件夹: {stats['folders']}个")
    print(f"子文件夹: {stats['subfolders']}个")
    print(f"原子笔记: {stats['atomic_notes']}篇")
    print(f"知识钩子: {stats['hooks']}个")
    print(f"输出目录: {base_path}")
    print("="*50)
    
    print(f"\n下一步操作：")
    print(f"1. 在Obsidian中打开: {base_path}")
    print(f"2. 打开总览笔记: {base_filename}学习总览.md")
    print(f"3. 开始你的学习之旅！")

def print_usage():
    """打印使用说明"""
    print("""
🔧 全自动知识库构建器 - 原子笔记不链接总览版

📋 一键完成所有操作：
1️⃣ 解析Markdown大纲
2️⃣ 创建文件夹结构
3️⃣ 提取钩子内容
4️⃣ 建立单向链接（原子→MOC→总览）
5️⃣ 生成总览导航

📋 使用方法：
1. 基本用法（自动检测）：
   python 全自动知识库构建器_修正版.py

2. 指定大纲文件：
   python 全自动知识库构建器_修正版.py 我的大纲.md

3. 指定文件和输出目录：
   python 全自动知识库构建器_修正版.py 我的大纲.md ./输出目录

📋 大纲格式要求：
## 主题一           → 创建顶级文件夹
*核心概念1*        → 斜体内容将写入MOC笔记的核心概念部分
*核心概念2*        → 可以添加多个核心概念
### 子主题1        → 创建子文件夹
- 文章标题1        → 创建原子笔记
- 钩子: 问题1      → 添加思考钩子到文章1
- 钩子: 问题2      → 添加更多钩子
- 文章标题2        → 创建另一个原子笔记
- 钩子: 问题3      → 添加钩子到文章2

🎯 输出结果：
- 完整的Obsidian知识库结构
- 所有钩子已写入对应笔记
- 二级标题下的斜体内容已写入对应MOC笔记的核心概念部分
- 单向链接网络：
  - 原子笔记 → MOC笔记
  - MOC笔记 → 学习总览
  - 原子笔记 → 学习总览（无链接）
- 立即可用！

🔗 链接结构：
- 原子笔记 → MOC笔记（单向）
- MOC笔记 → 学习总览（单向）
- 原子笔记 → 学习总览（无链接）
""")

if __name__ == "__main__":
    import sys
    
    if len(sys.argv) == 1:
        build_complete_knowledge_base()
    elif len(sys.argv) == 2:
        if sys.argv[1] in ['-h', '--help', 'help']:
            print_usage()
        else:
            build_complete_knowledge_base(sys.argv[1])
    elif len(sys.argv) == 3:
        build_complete_knowledge_base(sys.argv[1], sys.argv[2])
    else:
        print_usage()
```

## 常见问题解答

### Q: 我需要安装Python吗？
A: 是的，你需要安装Python 3.x版本才能运行这个脚本。你可以从 [Python官网](https://www.python.org/downloads/) 下载并安装。

### Q: 我需要安装其他库吗？
A: 不需要，这个脚本只使用了Python的标准库，不需要安装额外的第三方库。

### Q: 如何修改输出的文件名格式？
A: 你可以修改代码中的 `clean_filename` 函数来改变文件名的处理方式。

### Q: 如何添加更多的钩子或内容到笔记中？
A: 你可以修改创建原子笔记和MOC笔记的代码部分，添加你想要的内容。

### Q: 这个工具可以在Mac或Linux上使用吗？
A: 是的，这个工具是跨平台的，可以在Windows、Mac和Linux上使用，只要安装了Python。

## 总结

这个全自动知识库构建器是一个非常实用的工具，可以帮助你快速构建Obsidian知识库。它特别适合那些想要系统化学习某个主题的人，只需要准备一个Markdown大纲，就能自动生成完整的知识库结构。

希望这个教学导读对你有所帮助！如果你有任何问题或建议，欢迎提出反馈。